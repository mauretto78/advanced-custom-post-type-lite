(()=>{"use strict";var __webpack_modules__={4226:(__unused_webpack_module,exports,__webpack_require__)=>{eval('\n\nvar React = __webpack_require__(7294);\n\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = "") => {\n  const colonSeparated = value.split(":");\n  if (value.slice(0, 1) === "@") {\n    if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n      return null;\n    }\n    provider = colonSeparated.shift().slice(1);\n  }\n  if (colonSeparated.length > 3 || !colonSeparated.length) {\n    return null;\n  }\n  if (colonSeparated.length > 1) {\n    const name2 = colonSeparated.pop();\n    const prefix = colonSeparated.pop();\n    const result = {\n      // Allow provider without \'@\': "provider:prefix:name"\n      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n      prefix,\n      name: name2\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  const name = colonSeparated[0];\n  const dashSeparated = name.split("-");\n  if (dashSeparated.length > 1) {\n    const result = {\n      provider,\n      prefix: dashSeparated.shift(),\n      name: dashSeparated.join("-")\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  if (allowSimpleName && provider === "") {\n    const result = {\n      provider,\n      prefix: "",\n      name\n    };\n    return validate && !validateIconName(result, allowSimpleName) ? null : result;\n  }\n  return null;\n};\nconst validateIconName = (icon, allowSimpleName) => {\n  if (!icon) {\n    return false;\n  }\n  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\n\nconst defaultIconDimensions = Object.freeze(\n  {\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n  }\n);\nconst defaultIconTransformations = Object.freeze({\n  rotate: 0,\n  vFlip: false,\n  hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n  ...defaultIconDimensions,\n  ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n  ...defaultIconProps,\n  body: "",\n  hidden: false\n});\n\nfunction mergeIconTransformations(obj1, obj2) {\n  const result = {};\n  if (!obj1.hFlip !== !obj2.hFlip) {\n    result.hFlip = true;\n  }\n  if (!obj1.vFlip !== !obj2.vFlip) {\n    result.vFlip = true;\n  }\n  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n  if (rotate) {\n    result.rotate = rotate;\n  }\n  return result;\n}\n\nfunction mergeIconData(parent, child) {\n  const result = mergeIconTransformations(parent, child);\n  for (const key in defaultExtendedIconProps) {\n    if (key in defaultIconTransformations) {\n      if (key in parent && !(key in result)) {\n        result[key] = defaultIconTransformations[key];\n      }\n    } else if (key in child) {\n      result[key] = child[key];\n    } else if (key in parent) {\n      result[key] = parent[key];\n    }\n  }\n  return result;\n}\n\nfunction getIconsTree(data, names) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  const resolved = /* @__PURE__ */ Object.create(null);\n  function resolve(name) {\n    if (icons[name]) {\n      return resolved[name] = [];\n    }\n    if (!(name in resolved)) {\n      resolved[name] = null;\n      const parent = aliases[name] && aliases[name].parent;\n      const value = parent && resolve(parent);\n      if (value) {\n        resolved[name] = [parent].concat(value);\n      }\n    }\n    return resolved[name];\n  }\n  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n  return resolved;\n}\n\nfunction internalGetIconData(data, name, tree) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  let currentProps = {};\n  function parse(name2) {\n    currentProps = mergeIconData(\n      icons[name2] || aliases[name2],\n      currentProps\n    );\n  }\n  parse(name);\n  tree.forEach(parse);\n  return mergeIconData(data, currentProps);\n}\n\nfunction parseIconSet(data, callback) {\n  const names = [];\n  if (typeof data !== "object" || typeof data.icons !== "object") {\n    return names;\n  }\n  if (data.not_found instanceof Array) {\n    data.not_found.forEach((name) => {\n      callback(name, null);\n      names.push(name);\n    });\n  }\n  const tree = getIconsTree(data);\n  for (const name in tree) {\n    const item = tree[name];\n    if (item) {\n      callback(name, internalGetIconData(data, name, item));\n      names.push(name);\n    }\n  }\n  return names;\n}\n\nconst optionalPropertyDefaults = {\n  provider: "",\n  aliases: {},\n  not_found: {},\n  ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n  for (const prop in defaults) {\n    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction quicklyValidateIconSet(obj) {\n  if (typeof obj !== "object" || obj === null) {\n    return null;\n  }\n  const data = obj;\n  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {\n    return null;\n  }\n  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n    return null;\n  }\n  const icons = data.icons;\n  for (const name in icons) {\n    const icon = icons[name];\n    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(\n      icon,\n      defaultExtendedIconProps\n    )) {\n      return null;\n    }\n  }\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  for (const name in aliases) {\n    const icon = aliases[name];\n    const parent = icon.parent;\n    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(\n      icon,\n      defaultExtendedIconProps\n    )) {\n      return null;\n    }\n  }\n  return data;\n}\n\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n  return {\n    provider,\n    prefix,\n    icons: /* @__PURE__ */ Object.create(null),\n    missing: /* @__PURE__ */ new Set()\n  };\n}\nfunction getStorage(provider, prefix) {\n  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n  if (!quicklyValidateIconSet(data)) {\n    return [];\n  }\n  return parseIconSet(data, (name, icon) => {\n    if (icon) {\n      storage.icons[name] = icon;\n    } else {\n      storage.missing.add(name);\n    }\n  });\n}\nfunction addIconToStorage(storage, name, icon) {\n  try {\n    if (typeof icon.body === "string") {\n      storage.icons[name] = { ...icon };\n      return true;\n    }\n  } catch (err) {\n  }\n  return false;\n}\nfunction listIcons(provider, prefix) {\n  let allIcons = [];\n  const providers = typeof provider === "string" ? [provider] : Object.keys(dataStorage);\n  providers.forEach((provider2) => {\n    const prefixes = typeof provider2 === "string" && typeof prefix === "string" ? [prefix] : Object.keys(dataStorage[provider2] || {});\n    prefixes.forEach((prefix2) => {\n      const storage = getStorage(provider2, prefix2);\n      allIcons = allIcons.concat(\n        Object.keys(storage.icons).map(\n          (name) => (provider2 !== "" ? "@" + provider2 + ":" : "") + prefix2 + ":" + name\n        )\n      );\n    });\n  });\n  return allIcons;\n}\n\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n  if (typeof allow === "boolean") {\n    simpleNames = allow;\n  }\n  return simpleNames;\n}\nfunction getIconData(name) {\n  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;\n  if (icon) {\n    const storage = getStorage(icon.provider, icon.prefix);\n    const iconName = icon.name;\n    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n  }\n}\nfunction addIcon(name, data) {\n  const icon = stringToIcon(name, true, simpleNames);\n  if (!icon) {\n    return false;\n  }\n  const storage = getStorage(icon.provider, icon.prefix);\n  return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection(data, provider) {\n  if (typeof data !== "object") {\n    return false;\n  }\n  if (typeof provider !== "string") {\n    provider = data.provider || "";\n  }\n  if (simpleNames && !provider && !data.prefix) {\n    let added = false;\n    if (quicklyValidateIconSet(data)) {\n      data.prefix = "";\n      parseIconSet(data, (name, icon) => {\n        if (icon && addIcon(name, icon)) {\n          added = true;\n        }\n      });\n    }\n    return added;\n  }\n  const prefix = data.prefix;\n  if (!validateIconName({\n    provider,\n    prefix,\n    name: "a"\n  })) {\n    return false;\n  }\n  const storage = getStorage(provider, prefix);\n  return !!addIconSet(storage, data);\n}\nfunction iconExists(name) {\n  return !!getIconData(name);\n}\nfunction getIcon(name) {\n  const result = getIconData(name);\n  return result ? {\n    ...defaultIconProps,\n    ...result\n  } : null;\n}\n\nconst defaultIconSizeCustomisations = Object.freeze({\n  width: null,\n  height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n  // Dimensions\n  ...defaultIconSizeCustomisations,\n  // Transformations\n  ...defaultIconTransformations\n});\n\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n  if (ratio === 1) {\n    return size;\n  }\n  precision = precision || 100;\n  if (typeof size === "number") {\n    return Math.ceil(size * ratio * precision) / precision;\n  }\n  if (typeof size !== "string") {\n    return size;\n  }\n  const oldParts = size.split(unitsSplit);\n  if (oldParts === null || !oldParts.length) {\n    return size;\n  }\n  const newParts = [];\n  let code = oldParts.shift();\n  let isNumber = unitsTest.test(code);\n  while (true) {\n    if (isNumber) {\n      const num = parseFloat(code);\n      if (isNaN(num)) {\n        newParts.push(code);\n      } else {\n        newParts.push(Math.ceil(num * ratio * precision) / precision);\n      }\n    } else {\n      newParts.push(code);\n    }\n    code = oldParts.shift();\n    if (code === void 0) {\n      return newParts.join("");\n    }\n    isNumber = !isNumber;\n  }\n}\n\nconst isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";\nfunction iconToSVG(icon, customisations) {\n  const fullIcon = {\n    ...defaultIconProps,\n    ...icon\n  };\n  const fullCustomisations = {\n    ...defaultIconCustomisations,\n    ...customisations\n  };\n  const box = {\n    left: fullIcon.left,\n    top: fullIcon.top,\n    width: fullIcon.width,\n    height: fullIcon.height\n  };\n  let body = fullIcon.body;\n  [fullIcon, fullCustomisations].forEach((props) => {\n    const transformations = [];\n    const hFlip = props.hFlip;\n    const vFlip = props.vFlip;\n    let rotation = props.rotate;\n    if (hFlip) {\n      if (vFlip) {\n        rotation += 2;\n      } else {\n        transformations.push(\n          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"\n        );\n        transformations.push("scale(-1 1)");\n        box.top = box.left = 0;\n      }\n    } else if (vFlip) {\n      transformations.push(\n        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"\n      );\n      transformations.push("scale(1 -1)");\n      box.top = box.left = 0;\n    }\n    let tempValue;\n    if (rotation < 0) {\n      rotation -= Math.floor(rotation / 4) * 4;\n    }\n    rotation = rotation % 4;\n    switch (rotation) {\n      case 1:\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift(\n          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"\n        );\n        break;\n      case 2:\n        transformations.unshift(\n          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"\n        );\n        break;\n      case 3:\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift(\n          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"\n        );\n        break;\n    }\n    if (rotation % 2 === 1) {\n      if (box.left !== box.top) {\n        tempValue = box.left;\n        box.left = box.top;\n        box.top = tempValue;\n      }\n      if (box.width !== box.height) {\n        tempValue = box.width;\n        box.width = box.height;\n        box.height = tempValue;\n      }\n    }\n    if (transformations.length) {\n      body = \'<g transform="\' + transformations.join(" ") + \'">\' + body + "</g>";\n    }\n  });\n  const customisationsWidth = fullCustomisations.width;\n  const customisationsHeight = fullCustomisations.height;\n  const boxWidth = box.width;\n  const boxHeight = box.height;\n  let width;\n  let height;\n  if (customisationsWidth === null) {\n    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;\n    width = calculateSize(height, boxWidth / boxHeight);\n  } else {\n    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;\n    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;\n  }\n  const attributes = {};\n  const setAttr = (prop, value) => {\n    if (!isUnsetKeyword(value)) {\n      attributes[prop] = value.toString();\n    }\n  };\n  setAttr("width", width);\n  setAttr("height", height);\n  attributes.viewBox = box.left.toString() + " " + box.top.toString() + " " + boxWidth.toString() + " " + boxHeight.toString();\n  return {\n    attributes,\n    body\n  };\n}\n\nconst regex = /\\sid="(\\S+)"/g;\nconst randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n  const ids = [];\n  let match;\n  while (match = regex.exec(body)) {\n    ids.push(match[1]);\n  }\n  if (!ids.length) {\n    return body;\n  }\n  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);\n  ids.forEach((id) => {\n    const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();\n    const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n    body = body.replace(\n      // Allowed characters before id: [#;"]\n      // Allowed characters after id: [)"], .[a-z]\n      new RegExp(\'([#;"])(\' + escapedID + \')([")]|\\\\.[a-z])\', "g"),\n      "$1" + newID + suffix + "$3"\n    );\n  });\n  body = body.replace(new RegExp(suffix, "g"), "");\n  return body;\n}\n\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n  storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n  return storage[provider] || storage[""];\n}\n\nfunction createAPIConfig(source) {\n  let resources;\n  if (typeof source.resources === "string") {\n    resources = [source.resources];\n  } else {\n    resources = source.resources;\n    if (!(resources instanceof Array) || !resources.length) {\n      return null;\n    }\n  }\n  const result = {\n    // API hosts\n    resources,\n    // Root path\n    path: source.path || "/",\n    // URL length limit\n    maxURL: source.maxURL || 500,\n    // Timeout before next host is used.\n    rotate: source.rotate || 750,\n    // Timeout before failing query.\n    timeout: source.timeout || 5e3,\n    // Randomise default API end point.\n    random: source.random === true,\n    // Start index\n    index: source.index || 0,\n    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n    dataAfterTimeout: source.dataAfterTimeout !== false\n  };\n  return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n  "https://api.simplesvg.com",\n  "https://api.unisvg.com"\n];\nconst fallBackAPI = [];\nwhile (fallBackAPISources.length > 0) {\n  if (fallBackAPISources.length === 1) {\n    fallBackAPI.push(fallBackAPISources.shift());\n  } else {\n    if (Math.random() > 0.5) {\n      fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n      fallBackAPI.push(fallBackAPISources.pop());\n    }\n  }\n}\nconfigStorage[""] = createAPIConfig({\n  resources: ["https://api.iconify.design"].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n  const config = createAPIConfig(customConfig);\n  if (config === null) {\n    return false;\n  }\n  configStorage[provider] = config;\n  return true;\n}\nfunction getAPIConfig(provider) {\n  return configStorage[provider];\n}\nfunction listAPIProviders() {\n  return Object.keys(configStorage);\n}\n\nconst detectFetch = () => {\n  let callback;\n  try {\n    callback = fetch;\n    if (typeof callback === "function") {\n      return callback;\n    }\n  } catch (err) {\n  }\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n  fetchModule = fetch2;\n}\nfunction getFetch() {\n  return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n  const config = getAPIConfig(provider);\n  if (!config) {\n    return 0;\n  }\n  let result;\n  if (!config.maxURL) {\n    result = 0;\n  } else {\n    let maxHostLength = 0;\n    config.resources.forEach((item) => {\n      const host = item;\n      maxHostLength = Math.max(maxHostLength, host.length);\n    });\n    const url = prefix + ".json?icons=";\n    result = config.maxURL - maxHostLength - config.path.length - url.length;\n  }\n  return result;\n}\nfunction shouldAbort(status) {\n  return status === 404;\n}\nconst prepare = (provider, prefix, icons) => {\n  const results = [];\n  const maxLength = calculateMaxLength(provider, prefix);\n  const type = "icons";\n  let item = {\n    type,\n    provider,\n    prefix,\n    icons: []\n  };\n  let length = 0;\n  icons.forEach((name, index) => {\n    length += name.length + 1;\n    if (length >= maxLength && index > 0) {\n      results.push(item);\n      item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n      };\n      length = name.length;\n    }\n    item.icons.push(name);\n  });\n  results.push(item);\n  return results;\n};\nfunction getPath(provider) {\n  if (typeof provider === "string") {\n    const config = getAPIConfig(provider);\n    if (config) {\n      return config.path;\n    }\n  }\n  return "/";\n}\nconst send = (host, params, callback) => {\n  if (!fetchModule) {\n    callback("abort", 424);\n    return;\n  }\n  let path = getPath(params.provider);\n  switch (params.type) {\n    case "icons": {\n      const prefix = params.prefix;\n      const icons = params.icons;\n      const iconsList = icons.join(",");\n      const urlParams = new URLSearchParams({\n        icons: iconsList\n      });\n      path += prefix + ".json?" + urlParams.toString();\n      break;\n    }\n    case "custom": {\n      const uri = params.uri;\n      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;\n      break;\n    }\n    default:\n      callback("abort", 400);\n      return;\n  }\n  let defaultError = 503;\n  fetchModule(host + path).then((response) => {\n    const status = response.status;\n    if (status !== 200) {\n      setTimeout(() => {\n        callback(shouldAbort(status) ? "abort" : "next", status);\n      });\n      return;\n    }\n    defaultError = 501;\n    return response.json();\n  }).then((data) => {\n    if (typeof data !== "object" || data === null) {\n      setTimeout(() => {\n        if (data === 404) {\n          callback("abort", data);\n        } else {\n          callback("next", defaultError);\n        }\n      });\n      return;\n    }\n    setTimeout(() => {\n      callback("success", data);\n    });\n  }).catch(() => {\n    callback("next", defaultError);\n  });\n};\nconst fetchAPIModule = {\n  prepare,\n  send\n};\n\nfunction sortIcons(icons) {\n  const result = {\n    loaded: [],\n    missing: [],\n    pending: []\n  };\n  const storage = /* @__PURE__ */ Object.create(null);\n  icons.sort((a, b) => {\n    if (a.provider !== b.provider) {\n      return a.provider.localeCompare(b.provider);\n    }\n    if (a.prefix !== b.prefix) {\n      return a.prefix.localeCompare(b.prefix);\n    }\n    return a.name.localeCompare(b.name);\n  });\n  let lastIcon = {\n    provider: "",\n    prefix: "",\n    name: ""\n  };\n  icons.forEach((icon) => {\n    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n      return;\n    }\n    lastIcon = icon;\n    const provider = icon.provider;\n    const prefix = icon.prefix;\n    const name = icon.name;\n    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n    let list;\n    if (name in localStorage.icons) {\n      list = result.loaded;\n    } else if (prefix === "" || localStorage.missing.has(name)) {\n      list = result.missing;\n    } else {\n      list = result.pending;\n    }\n    const item = {\n      provider,\n      prefix,\n      name\n    };\n    list.push(item);\n  });\n  return result;\n}\n\nfunction removeCallback(storages, id) {\n  storages.forEach((storage) => {\n    const items = storage.loaderCallbacks;\n    if (items) {\n      storage.loaderCallbacks = items.filter((row) => row.id !== id);\n    }\n  });\n}\nfunction updateCallbacks(storage) {\n  if (!storage.pendingCallbacksFlag) {\n    storage.pendingCallbacksFlag = true;\n    setTimeout(() => {\n      storage.pendingCallbacksFlag = false;\n      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n      if (!items.length) {\n        return;\n      }\n      let hasPending = false;\n      const provider = storage.provider;\n      const prefix = storage.prefix;\n      items.forEach((item) => {\n        const icons = item.icons;\n        const oldLength = icons.pending.length;\n        icons.pending = icons.pending.filter((icon) => {\n          if (icon.prefix !== prefix) {\n            return true;\n          }\n          const name = icon.name;\n          if (storage.icons[name]) {\n            icons.loaded.push({\n              provider,\n              prefix,\n              name\n            });\n          } else if (storage.missing.has(name)) {\n            icons.missing.push({\n              provider,\n              prefix,\n              name\n            });\n          } else {\n            hasPending = true;\n            return true;\n          }\n          return false;\n        });\n        if (icons.pending.length !== oldLength) {\n          if (!hasPending) {\n            removeCallback([storage], item.id);\n          }\n          item.callback(\n            icons.loaded.slice(0),\n            icons.missing.slice(0),\n            icons.pending.slice(0),\n            item.abort\n          );\n        }\n      });\n    });\n  }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n  const id = idCounter++;\n  const abort = removeCallback.bind(null, pendingSources, id);\n  if (!icons.pending.length) {\n    return abort;\n  }\n  const item = {\n    id,\n    icons,\n    callback,\n    abort\n  };\n  pendingSources.forEach((storage) => {\n    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n  });\n  return abort;\n}\n\nfunction listToIcons(list, validate = true, simpleNames = false) {\n  const result = [];\n  list.forEach((item) => {\n    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames) : item;\n    if (icon) {\n      result.push(icon);\n    }\n  });\n  return result;\n}\n\n// src/config.ts\nvar defaultConfig = {\n  resources: [],\n  index: 0,\n  timeout: 2e3,\n  rotate: 750,\n  random: false,\n  dataAfterTimeout: false\n};\n\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n  const resourcesCount = config.resources.length;\n  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n  let resources;\n  if (config.random) {\n    let list = config.resources.slice(0);\n    resources = [];\n    while (list.length > 1) {\n      const nextIndex = Math.floor(Math.random() * list.length);\n      resources.push(list[nextIndex]);\n      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n    }\n    resources = resources.concat(list);\n  } else {\n    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n  }\n  const startTime = Date.now();\n  let status = "pending";\n  let queriesSent = 0;\n  let lastError;\n  let timer = null;\n  let queue = [];\n  let doneCallbacks = [];\n  if (typeof done === "function") {\n    doneCallbacks.push(done);\n  }\n  function resetTimer() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function abort() {\n    if (status === "pending") {\n      status = "aborted";\n    }\n    resetTimer();\n    queue.forEach((item) => {\n      if (item.status === "pending") {\n        item.status = "aborted";\n      }\n    });\n    queue = [];\n  }\n  function subscribe(callback, overwrite) {\n    if (overwrite) {\n      doneCallbacks = [];\n    }\n    if (typeof callback === "function") {\n      doneCallbacks.push(callback);\n    }\n  }\n  function getQueryStatus() {\n    return {\n      startTime,\n      payload,\n      status,\n      queriesSent,\n      queriesPending: queue.length,\n      subscribe,\n      abort\n    };\n  }\n  function failQuery() {\n    status = "failed";\n    doneCallbacks.forEach((callback) => {\n      callback(void 0, lastError);\n    });\n  }\n  function clearQueue() {\n    queue.forEach((item) => {\n      if (item.status === "pending") {\n        item.status = "aborted";\n      }\n    });\n    queue = [];\n  }\n  function moduleResponse(item, response, data) {\n    const isError = response !== "success";\n    queue = queue.filter((queued) => queued !== item);\n    switch (status) {\n      case "pending":\n        break;\n      case "failed":\n        if (isError || !config.dataAfterTimeout) {\n          return;\n        }\n        break;\n      default:\n        return;\n    }\n    if (response === "abort") {\n      lastError = data;\n      failQuery();\n      return;\n    }\n    if (isError) {\n      lastError = data;\n      if (!queue.length) {\n        if (!resources.length) {\n          failQuery();\n        } else {\n          execNext();\n        }\n      }\n      return;\n    }\n    resetTimer();\n    clearQueue();\n    if (!config.random) {\n      const index = config.resources.indexOf(item.resource);\n      if (index !== -1 && index !== config.index) {\n        config.index = index;\n      }\n    }\n    status = "completed";\n    doneCallbacks.forEach((callback) => {\n      callback(data);\n    });\n  }\n  function execNext() {\n    if (status !== "pending") {\n      return;\n    }\n    resetTimer();\n    const resource = resources.shift();\n    if (resource === void 0) {\n      if (queue.length) {\n        timer = setTimeout(() => {\n          resetTimer();\n          if (status === "pending") {\n            clearQueue();\n            failQuery();\n          }\n        }, config.timeout);\n        return;\n      }\n      failQuery();\n      return;\n    }\n    const item = {\n      status: "pending",\n      resource,\n      callback: (status2, data) => {\n        moduleResponse(item, status2, data);\n      }\n    };\n    queue.push(item);\n    queriesSent++;\n    timer = setTimeout(execNext, config.rotate);\n    query(resource, payload, item.callback);\n  }\n  setTimeout(execNext);\n  return getQueryStatus;\n}\n\n// src/index.ts\nfunction initRedundancy(cfg) {\n  const config = {\n    ...defaultConfig,\n    ...cfg\n  };\n  let queries = [];\n  function cleanup() {\n    queries = queries.filter((item) => item().status === "pending");\n  }\n  function query(payload, queryCallback, doneCallback) {\n    const query2 = sendQuery(\n      config,\n      payload,\n      queryCallback,\n      (data, error) => {\n        cleanup();\n        if (doneCallback) {\n          doneCallback(data, error);\n        }\n      }\n    );\n    queries.push(query2);\n    return query2;\n  }\n  function find(callback) {\n    return queries.find((value) => {\n      return callback(value);\n    }) || null;\n  }\n  const instance = {\n    query,\n    find,\n    setIndex: (index) => {\n      config.index = index;\n    },\n    getIndex: () => config.index,\n    cleanup\n  };\n  return instance;\n}\n\nfunction emptyCallback$1() {\n}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n  if (!redundancyCache[provider]) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n      return;\n    }\n    const redundancy = initRedundancy(config);\n    const cachedReundancy = {\n      config,\n      redundancy\n    };\n    redundancyCache[provider] = cachedReundancy;\n  }\n  return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n  let redundancy;\n  let send;\n  if (typeof target === "string") {\n    const api = getAPIModule(target);\n    if (!api) {\n      callback(void 0, 424);\n      return emptyCallback$1;\n    }\n    send = api.send;\n    const cached = getRedundancyCache(target);\n    if (cached) {\n      redundancy = cached.redundancy;\n    }\n  } else {\n    const config = createAPIConfig(target);\n    if (config) {\n      redundancy = initRedundancy(config);\n      const moduleKey = target.resources ? target.resources[0] : "";\n      const api = getAPIModule(moduleKey);\n      if (api) {\n        send = api.send;\n      }\n    }\n  }\n  if (!redundancy || !send) {\n    callback(void 0, 424);\n    return emptyCallback$1;\n  }\n  return redundancy.query(query, send, callback)().abort;\n}\n\nconst browserCacheVersion = "iconify2";\nconst browserCachePrefix = "iconify";\nconst browserCacheCountKey = browserCachePrefix + "-count";\nconst browserCacheVersionKey = browserCachePrefix + "-version";\nconst browserStorageHour = 36e5;\nconst browserStorageCacheExpiration = 168;\n\nfunction getStoredItem(func, key) {\n  try {\n    return func.getItem(key);\n  } catch (err) {\n  }\n}\nfunction setStoredItem(func, key, value) {\n  try {\n    func.setItem(key, value);\n    return true;\n  } catch (err) {\n  }\n}\nfunction removeStoredItem(func, key) {\n  try {\n    func.removeItem(key);\n  } catch (err) {\n  }\n}\n\nfunction setBrowserStorageItemsCount(storage, value) {\n  return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n  return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\n\nconst browserStorageConfig = {\n  local: true,\n  session: true\n};\nconst browserStorageEmptyItems = {\n  local: /* @__PURE__ */ new Set(),\n  session: /* @__PURE__ */ new Set()\n};\nlet browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n  browserStorageStatus = status;\n}\n\nlet _window = typeof window === "undefined" ? {} : window;\nfunction getBrowserStorage(key) {\n  const attr = key + "Storage";\n  try {\n    if (_window && _window[attr] && typeof _window[attr].length === "number") {\n      return _window[attr];\n    }\n  } catch (err) {\n  }\n  browserStorageConfig[key] = false;\n}\n\nfunction iterateBrowserStorage(key, callback) {\n  const func = getBrowserStorage(key);\n  if (!func) {\n    return;\n  }\n  const version = getStoredItem(func, browserCacheVersionKey);\n  if (version !== browserCacheVersion) {\n    if (version) {\n      const total2 = getBrowserStorageItemsCount(func);\n      for (let i = 0; i < total2; i++) {\n        removeStoredItem(func, browserCachePrefix + i.toString());\n      }\n    }\n    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n    setBrowserStorageItemsCount(func, 0);\n    return;\n  }\n  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n  const parseItem = (index) => {\n    const name = browserCachePrefix + index.toString();\n    const item = getStoredItem(func, name);\n    if (typeof item !== "string") {\n      return;\n    }\n    try {\n      const data = JSON.parse(item);\n      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback\n      callback(data, index)) {\n        return true;\n      }\n    } catch (err) {\n    }\n    removeStoredItem(func, name);\n  };\n  let total = getBrowserStorageItemsCount(func);\n  for (let i = total - 1; i >= 0; i--) {\n    if (!parseItem(i)) {\n      if (i === total - 1) {\n        total--;\n        setBrowserStorageItemsCount(func, total);\n      } else {\n        browserStorageEmptyItems[key].add(i);\n      }\n    }\n  }\n}\n\nfunction initBrowserStorage() {\n  if (browserStorageStatus) {\n    return;\n  }\n  setBrowserStorageStatus(true);\n  for (const key in browserStorageConfig) {\n    iterateBrowserStorage(key, (item) => {\n      const iconSet = item.data;\n      const provider = item.provider;\n      const prefix = iconSet.prefix;\n      const storage = getStorage(\n        provider,\n        prefix\n      );\n      if (!addIconSet(storage, iconSet).length) {\n        return false;\n      }\n      const lastModified = iconSet.lastModified || -1;\n      storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n      return true;\n    });\n  }\n}\n\nfunction updateLastModified(storage, lastModified) {\n  const lastValue = storage.lastModifiedCached;\n  if (\n    // Matches or newer\n    lastValue && lastValue >= lastModified\n  ) {\n    return lastValue === lastModified;\n  }\n  storage.lastModifiedCached = lastModified;\n  if (lastValue) {\n    for (const key in browserStorageConfig) {\n      iterateBrowserStorage(key, (item) => {\n        const iconSet = item.data;\n        return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n      });\n    }\n  }\n  return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n  if (!browserStorageStatus) {\n    initBrowserStorage();\n  }\n  function store(key) {\n    let func;\n    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n      return;\n    }\n    const set = browserStorageEmptyItems[key];\n    let index;\n    if (set.size) {\n      set.delete(index = Array.from(set).shift());\n    } else {\n      index = getBrowserStorageItemsCount(func);\n      if (!setBrowserStorageItemsCount(func, index + 1)) {\n        return;\n      }\n    }\n    const item = {\n      cached: Math.floor(Date.now() / browserStorageHour),\n      provider: storage.provider,\n      data\n    };\n    return setStoredItem(\n      func,\n      browserCachePrefix + index.toString(),\n      JSON.stringify(item)\n    );\n  }\n  if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n    return;\n  }\n  if (!Object.keys(data.icons).length) {\n    return;\n  }\n  if (data.not_found) {\n    data = Object.assign({}, data);\n    delete data.not_found;\n  }\n  if (!store("local")) {\n    store("session");\n  }\n}\n\nfunction emptyCallback() {\n}\nfunction loadedNewIcons(storage) {\n  if (!storage.iconsLoaderFlag) {\n    storage.iconsLoaderFlag = true;\n    setTimeout(() => {\n      storage.iconsLoaderFlag = false;\n      updateCallbacks(storage);\n    });\n  }\n}\nfunction loadNewIcons(storage, icons) {\n  if (!storage.iconsToLoad) {\n    storage.iconsToLoad = icons;\n  } else {\n    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n  }\n  if (!storage.iconsQueueFlag) {\n    storage.iconsQueueFlag = true;\n    setTimeout(() => {\n      storage.iconsQueueFlag = false;\n      const { provider, prefix } = storage;\n      const icons2 = storage.iconsToLoad;\n      delete storage.iconsToLoad;\n      let api;\n      if (!icons2 || !(api = getAPIModule(provider))) {\n        return;\n      }\n      const params = api.prepare(provider, prefix, icons2);\n      params.forEach((item) => {\n        sendAPIQuery(provider, item, (data) => {\n          if (typeof data !== "object") {\n            item.icons.forEach((name) => {\n              storage.missing.add(name);\n            });\n          } else {\n            try {\n              const parsed = addIconSet(\n                storage,\n                data\n              );\n              if (!parsed.length) {\n                return;\n              }\n              const pending = storage.pendingIcons;\n              if (pending) {\n                parsed.forEach((name) => {\n                  pending.delete(name);\n                });\n              }\n              storeInBrowserStorage(storage, data);\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          loadedNewIcons(storage);\n        });\n      });\n    });\n  }\n}\nconst loadIcons = (icons, callback) => {\n  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n  const sortedIcons = sortIcons(cleanedIcons);\n  if (!sortedIcons.pending.length) {\n    let callCallback = true;\n    if (callback) {\n      setTimeout(() => {\n        if (callCallback) {\n          callback(\n            sortedIcons.loaded,\n            sortedIcons.missing,\n            sortedIcons.pending,\n            emptyCallback\n          );\n        }\n      });\n    }\n    return () => {\n      callCallback = false;\n    };\n  }\n  const newIcons = /* @__PURE__ */ Object.create(null);\n  const sources = [];\n  let lastProvider, lastPrefix;\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix } = icon;\n    if (prefix === lastPrefix && provider === lastProvider) {\n      return;\n    }\n    lastProvider = provider;\n    lastPrefix = prefix;\n    sources.push(getStorage(provider, prefix));\n    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n    if (!providerNewIcons[prefix]) {\n      providerNewIcons[prefix] = [];\n    }\n  });\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix, name } = icon;\n    const storage = getStorage(provider, prefix);\n    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n    if (!pendingQueue.has(name)) {\n      pendingQueue.add(name);\n      newIcons[provider][prefix].push(name);\n    }\n  });\n  sources.forEach((storage) => {\n    const { provider, prefix } = storage;\n    if (newIcons[provider][prefix].length) {\n      loadNewIcons(storage, newIcons[provider][prefix]);\n    }\n  });\n  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon) => {\n  return new Promise((fulfill, reject) => {\n    const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;\n    if (!iconObj) {\n      reject(icon);\n      return;\n    }\n    loadIcons([iconObj || icon], (loaded) => {\n      if (loaded.length && iconObj) {\n        const data = getIconData(iconObj);\n        if (data) {\n          fulfill({\n            ...defaultIconProps,\n            ...data\n          });\n          return;\n        }\n      }\n      reject(icon);\n    });\n  });\n};\n\nfunction toggleBrowserCache(storage, value) {\n  switch (storage) {\n    case "local":\n    case "session":\n      browserStorageConfig[storage] = value;\n      break;\n    case "all":\n      for (const key in browserStorageConfig) {\n        browserStorageConfig[key] = value;\n      }\n      break;\n  }\n}\n\nfunction mergeCustomisations(defaults, item) {\n  const result = {\n    ...defaults\n  };\n  for (const key in item) {\n    const value = item[key];\n    const valueType = typeof value;\n    if (key in defaultIconSizeCustomisations) {\n      if (value === null || value && (valueType === "string" || valueType === "number")) {\n        result[key] = value;\n      }\n    } else if (valueType === typeof result[key]) {\n      result[key] = key === "rotate" ? value % 4 : value;\n    }\n  }\n  return result;\n}\n\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n  flip.split(separator).forEach((str) => {\n    const value = str.trim();\n    switch (value) {\n      case "horizontal":\n        custom.hFlip = true;\n        break;\n      case "vertical":\n        custom.vFlip = true;\n        break;\n    }\n  });\n}\n\nfunction rotateFromString(value, defaultValue = 0) {\n  const units = value.replace(/^-?[0-9.]*/, "");\n  function cleanup(value2) {\n    while (value2 < 0) {\n      value2 += 4;\n    }\n    return value2 % 4;\n  }\n  if (units === "") {\n    const num = parseInt(value);\n    return isNaN(num) ? 0 : cleanup(num);\n  } else if (units !== value) {\n    let split = 0;\n    switch (units) {\n      case "%":\n        split = 25;\n        break;\n      case "deg":\n        split = 90;\n    }\n    if (split) {\n      let num = parseFloat(value.slice(0, value.length - units.length));\n      if (isNaN(num)) {\n        return 0;\n      }\n      num = num / split;\n      return num % 1 === 0 ? cleanup(num) : 0;\n    }\n  }\n  return defaultValue;\n}\n\nfunction iconToHTML(body, attributes) {\n  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : \' xmlns:xlink="http://www.w3.org/1999/xlink"\';\n  for (const attr in attributes) {\n    renderAttribsHTML += " " + attr + \'="\' + attributes[attr] + \'"\';\n  }\n  return \'<svg xmlns="http://www.w3.org/2000/svg"\' + renderAttribsHTML + ">" + body + "</svg>";\n}\n\nfunction encodeSVGforURL(svg) {\n  return svg.replace(/"/g, "\'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\\s+/g, " ");\n}\nfunction svgToData(svg) {\n  return "data:image/svg+xml," + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n  return \'url("\' + svgToData(svg) + \'")\';\n}\n\nlet policy;\nfunction createPolicy() {\n  try {\n    policy = window.trustedTypes.createPolicy("iconify", {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      createHTML: (s) => s\n    });\n  } catch (err) {\n    policy = null;\n  }\n}\nfunction cleanUpInnerHTML(html) {\n  if (policy === void 0) {\n    createPolicy();\n  }\n  return policy ? policy.createHTML(html) : html;\n}\n\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false,\n};\n\n/**\n * Default SVG attributes\n */\nconst svgDefaults = {\n    \'xmlns\': \'http://www.w3.org/2000/svg\',\n    \'xmlnsXlink\': \'http://www.w3.org/1999/xlink\',\n    \'aria-hidden\': true,\n    \'role\': \'img\',\n};\n/**\n * Style modes\n */\nconst commonProps = {\n    display: \'inline-block\',\n};\nconst monotoneProps = {\n    backgroundColor: \'currentColor\',\n};\nconst coloredProps = {\n    backgroundColor: \'transparent\',\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: \'var(--svg)\',\n    Repeat: \'no-repeat\',\n    Size: \'100% 100%\',\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps,\n};\nfor (const prefix in propsToAddTo) {\n    const list = propsToAddTo[prefix];\n    for (const prop in propsToAdd) {\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */\nconst inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true,\n};\n/**\n * Fix size: add \'px\' to numbers\n */\nfunction fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \'px\' : \'\');\n}\n/**\n * Render icon\n */\nconst render = (\n// Icon must be validated before calling this function\nicon, \n// Partial properties\nprops, \n// True if icon should have vertical-align added\ninline, \n// Optional reference for SVG/SPAN, extracted by React.forwardRef()\nref) => {\n    // Get default properties\n    const defaultProps = inline\n        ? inlineDefaults\n        : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || \'svg\';\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...(mode === \'svg\' ? svgDefaults : {}),\n        ref,\n    };\n    // Get element properties\n    for (let key in props) {\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch (key) {\n            // Properties to ignore\n            case \'icon\':\n            case \'style\':\n            case \'children\':\n            case \'onLoad\':\n            case \'mode\':\n            case \'_ref\':\n            case \'_inline\':\n                break;\n            // Boolean attributes\n            case \'inline\':\n            case \'hFlip\':\n            case \'vFlip\':\n                customisations[key] =\n                    value === true || value === \'true\' || value === 1;\n                break;\n            // Flip as string: \'horizontal,vertical\'\n            case \'flip\':\n                if (typeof value === \'string\') {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \'color\':\n                style.color = value;\n                break;\n            // Rotation as string\n            case \'rotate\':\n                if (typeof value === \'string\') {\n                    customisations[key] = rotateFromString(value);\n                }\n                else if (typeof value === \'number\') {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \'ariaHidden\':\n            case \'aria-hidden\':\n                if (value !== true && value !== \'true\') {\n                    delete componentProps[\'aria-hidden\'];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \'-0.125em\';\n    }\n    if (mode === \'svg\') {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle,\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on "id" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === \'string\') {\n            // Convert \'-\' to \'_\' to avoid errors in animations\n            id = id.replace(/-/g, \'_\');\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? () => id + \'ID\' + localCounter++ : \'iconifyReact\')),\n        };\n        return React.createElement(\'svg\', componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === \'mask\' ||\n        (mode === \'bg\' ? false : body.indexOf(\'currentColor\') !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + \'\',\n        height: height + \'\',\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        \'--svg\': svgToURL(html),\n        \'width\': fixSize(renderAttribs.width),\n        \'height\': fixSize(renderAttribs.height),\n        ...commonProps,\n        ...(useMask ? monotoneProps : coloredProps),\n        ...customStyle,\n    };\n    return React.createElement(\'span\', componentProps);\n};\n\n/**\n * Enable cache\n */\nfunction enableCache(storage) {\n    toggleBrowserCache(storage, true);\n}\n/**\n * Disable cache\n */\nfunction disableCache(storage) {\n    toggleBrowserCache(storage, false);\n}\n/**\n * Initialise stuff\n */\n// Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\'\', fetchAPIModule);\n/**\n * Browser stuff\n */\nif (typeof document !== \'undefined\' && typeof window !== \'undefined\') {\n    // Set cache and load existing cache\n    initBrowserStorage();\n    const _window = window;\n    // Load icons from global "IconifyPreload"\n    if (_window.IconifyPreload !== void 0) {\n        const preload = _window.IconifyPreload;\n        const err = \'Invalid IconifyPreload syntax.\';\n        if (typeof preload === \'object\' && preload !== null) {\n            (preload instanceof Array ? preload : [preload]).forEach((item) => {\n                try {\n                    if (\n                    // Check if item is an object and not null/array\n                    typeof item !== \'object\' ||\n                        item === null ||\n                        item instanceof Array ||\n                        // Check for \'icons\' and \'prefix\'\n                        typeof item.icons !== \'object\' ||\n                        typeof item.prefix !== \'string\' ||\n                        // Add icon set\n                        !addCollection(item)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global "IconifyProviders"\n    if (_window.IconifyProviders !== void 0) {\n        const providers = _window.IconifyProviders;\n        if (typeof providers === \'object\' && providers !== null) {\n            for (let key in providers) {\n                const err = \'IconifyProviders[\' + key + \'] is invalid.\';\n                try {\n                    const value = providers[key];\n                    if (typeof value !== \'object\' ||\n                        !value ||\n                        value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            }\n        }\n    }\n}\nclass IconComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // Render placeholder before component is mounted\n            icon: null,\n        };\n    }\n    /**\n     * Abort loading icon\n     */\n    _abortLoading() {\n        if (this._loading) {\n            this._loading.abort();\n            this._loading = null;\n        }\n    }\n    /**\n     * Update state\n     */\n    _setData(icon) {\n        if (this.state.icon !== icon) {\n            this.setState({\n                icon,\n            });\n        }\n    }\n    /**\n     * Check if icon should be loaded\n     */\n    _checkIcon(changed) {\n        const state = this.state;\n        const icon = this.props.icon;\n        // Icon is an object\n        if (typeof icon === \'object\' &&\n            icon !== null &&\n            typeof icon.body === \'string\') {\n            // Stop loading\n            this._icon = \'\';\n            this._abortLoading();\n            if (changed || state.icon === null) {\n                // Set data if it was changed\n                this._setData({\n                    data: icon,\n                });\n            }\n            return;\n        }\n        // Invalid icon?\n        let iconName;\n        if (typeof icon !== \'string\' ||\n            (iconName = stringToIcon(icon, false, true)) === null) {\n            this._abortLoading();\n            this._setData(null);\n            return;\n        }\n        // Load icon\n        const data = getIconData(iconName);\n        if (!data) {\n            // Icon data is not available\n            if (!this._loading || this._loading.name !== icon) {\n                // New icon to load\n                this._abortLoading();\n                this._icon = \'\';\n                this._setData(null);\n                if (data !== null) {\n                    // Icon was not loaded\n                    this._loading = {\n                        name: icon,\n                        abort: loadIcons([iconName], this._checkIcon.bind(this, false)),\n                    };\n                }\n            }\n            return;\n        }\n        // Icon data is available\n        if (this._icon !== icon || state.icon === null) {\n            // New icon or icon has been loaded\n            this._abortLoading();\n            this._icon = icon;\n            // Add classes\n            const classes = [\'iconify\'];\n            if (iconName.prefix !== \'\') {\n                classes.push(\'iconify--\' + iconName.prefix);\n            }\n            if (iconName.provider !== \'\') {\n                classes.push(\'iconify--\' + iconName.provider);\n            }\n            // Set data\n            this._setData({\n                data,\n                classes,\n            });\n            if (this.props.onLoad) {\n                this.props.onLoad(icon);\n            }\n        }\n    }\n    /**\n     * Component mounted\n     */\n    componentDidMount() {\n        this._checkIcon(false);\n    }\n    /**\n     * Component updated\n     */\n    componentDidUpdate(oldProps) {\n        if (oldProps.icon !== this.props.icon) {\n            this._checkIcon(true);\n        }\n    }\n    /**\n     * Abort loading\n     */\n    componentWillUnmount() {\n        this._abortLoading();\n    }\n    /**\n     * Render\n     */\n    render() {\n        const props = this.props;\n        const icon = this.state.icon;\n        if (icon === null) {\n            // Render placeholder\n            return props.children\n                ? props.children\n                : React.createElement(\'span\', {});\n        }\n        // Add classes\n        let newProps = props;\n        if (icon.classes) {\n            newProps = {\n                ...props,\n                className: (typeof props.className === \'string\'\n                    ? props.className + \' \'\n                    : \'\') + icon.classes.join(\' \'),\n            };\n        }\n        // Render icon\n        return render({\n            ...defaultIconProps,\n            ...icon.data,\n        }, newProps, props._inline, props._ref);\n    }\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */\nconst Icon = React.forwardRef(function Icon(props, ref) {\n    const newProps = {\n        ...props,\n        _ref: ref,\n        _inline: false,\n    };\n    return React.createElement(IconComponent, newProps);\n});\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */\nconst InlineIcon = React.forwardRef(function InlineIcon(props, ref) {\n    const newProps = {\n        ...props,\n        _ref: ref,\n        _inline: true,\n    };\n    return React.createElement(IconComponent, newProps);\n});\n/**\n * Internal API\n */\nconst _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders,\n};\n\nexports.Icon = Icon;\nexports.InlineIcon = InlineIcon;\nexports._api = _api;\nexports.addAPIProvider = addAPIProvider;\nexports.addCollection = addCollection;\nexports.addIcon = addIcon;\nexports.buildIcon = iconToSVG;\nexports.calculateSize = calculateSize;\nexports.disableCache = disableCache;\nexports.enableCache = enableCache;\nexports.getIcon = getIcon;\nexports.iconExists = iconExists;\nexports.listIcons = listIcons;\nexports.loadIcon = loadIcon;\nexports.loadIcons = loadIcons;\nexports.replaceIDs = replaceIDs;\n\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./node_modules/@iconify/react/dist/iconify.js?')},857:(__unused_webpack_module,exports,__webpack_require__)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fieldHasOptions = exports.fieldsList = exports.fieldTypes = exports.fieldSettings = exports.fieldGroupsDisplay = undefined;\n\nvar _useTranslation = __webpack_require__(1422);\n\nvar _useTranslation2 = _interopRequireDefault(_useTranslation);\n\nvar _react = __webpack_require__(7294);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _resolvers = __webpack_require__(3729);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar fieldGroupsDisplay = exports.fieldGroupsDisplay = {\n    STANDARD: \"standard\",\n    ACCORDION: 'accordion',\n    VERTICAL_TABS: 'verticalTabs',\n    HORIZONTAL_TABS: 'horizontalTabs'\n};\n\nvar fieldSettings = exports.fieldSettings = {\n    MAX_NESTING: 4\n};\n\nvar fieldTypes = exports.fieldTypes = {\n    DATE: 'Date',\n    EMAIL: 'Email',\n    SELECT: 'Select',\n    TEXT: 'Text',\n    TEXTAREA: 'Textarea'\n};\n\n/**\n *\n * @return {[{options: [{label, value: string}, {label, value: string}], label: *}, {options: [], label: *}, {options: [], label: *}, {options: [], label: *}, {options: [], label: *}]}\n */\nvar fieldsList = exports.fieldsList = function fieldsList(nestingLevel) {\n\n    var fieldListElement = function fieldListElement(fieldType) {\n        var _resolveField = (0, _resolvers.resolveField)(fieldType),\n            label = _resolveField.label;\n\n        return { label: (0, _useTranslation2.default)(label), value: fieldType };\n    };\n\n    return [{\n        label: (0, _useTranslation2.default)(\"BASIC\"),\n        options: [fieldListElement(fieldTypes.TEXT), fieldListElement(fieldTypes.TEXTAREA), fieldListElement(fieldTypes.SELECT)]\n    }, {\n        label: (0, _useTranslation2.default)(\"SPECIALIZED FIELDS\"),\n        options: [fieldListElement(fieldTypes.DATE), fieldListElement(fieldTypes.EMAIL)]\n    }];\n};\n\n/**\n *\n * @param fieldType\n * @return {boolean}\n */\nvar fieldHasOptions = exports.fieldHasOptions = function fieldHasOptions(fieldType) {\n\n    return fieldType === fieldTypes.SELECT;\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/constants/fields.js?")},1895:(__unused_webpack_module,exports)=>{eval('\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nvar metaTypes = exports.metaTypes = {\n    CUSTOM_POST_TYPE: "customPostType",\n    OPTION_PAGE: "optionPage",\n    TAXONOMY: "taxonomy",\n    USER: "user"\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/constants/metaTypes.js?')},1422:(__unused_webpack_module,exports,__webpack_require__)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _strings = __webpack_require__(8029);\n\nvar useTranslation = function useTranslation(string, args) {\n\n    if (document.globals) {\n\n        var settings = document.globals;\n\n        if (typeof settings.globals === 'undefined') {\n            return string;\n        }\n\n        var translations = settings.globals.translations;\n\n        if (typeof translations === 'undefined') {\n            return string;\n        }\n\n        if (typeof translations[string] !== 'undefined' && translations[string] !== '') {\n\n            var translation = (0, _strings.htmlspecialcharsDecode)(translations[string]);\n\n            if (args !== null && typeof args !== 'undefined') {\n                for (var key in args) {\n                    translation = translation.replace(\"{{\" + key + \"}}\", args[key]);\n                }\n            }\n\n            return translation;\n        }\n\n        return string;\n    }\n\n    return string;\n}; /**\n    * Return a translated string from global document object\n    * @param string\n    * @returns {*}\n    */\nexports.default = useTranslation;\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/hooks/useTranslation.js?")},4040:(__unused_webpack_module,exports)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n *\n * @param needle\n * @param haystack\n * @return {boolean}\n */\nvar inArray = exports.inArray = function inArray(needle, haystack) {\n    var length = haystack.length;\n    for (var i = 0; i < length; i++) {\n        if (haystack[i] === needle) return true;\n    }\n\n    return false;\n};\n\n/**\n * Check if an object is empty\n * @param obj\n * @returns {boolean}\n */\nvar isEmpty = exports.isEmpty = function isEmpty(obj) {\n    return objLength(obj) === 0;\n};\n\n/**\n * Get object length\n * @param obj\n * @returns {number}\n */\nvar objLength = exports.objLength = function objLength(obj) {\n    return Object.keys(obj).length;\n};\n\n/**\n *\n * @param obj\n * @param key\n * @returns {boolean}\n */\nvar isset = exports.isset = function isset(obj, key) {\n    if (typeof obj === 'undefined') {\n        return false;\n    }\n\n    return typeof obj[key] !== 'undefined';\n};\n\n/**\n * Filter a JSON object (array) by id\n * @param jsonObject\n * @param id\n * @returns {*}\n */\nvar filterById = exports.filterById = function filterById(jsonObject, id) {\n    if (typeof jsonObject === 'undefined') {\n        return {};\n    }\n\n    var result = jsonObject.filter(function (jsonObject) {\n        return jsonObject['id'] === id;\n    });\n\n    if (result.length > 0) {\n        return result[0];\n    }\n\n    return {};\n};\n\n/**\n * Filter a JSON object (array) by label => value couple\n * @param jsonObject\n * @param label\n * @param value\n * @returns {*}\n */\nvar filterByLabel = exports.filterByLabel = function filterByLabel(jsonObject, label, value) {\n    if (typeof jsonObject === 'undefined') {\n        return {};\n    }\n\n    var result = jsonObject.filter(function (jsonObject) {\n        return jsonObject[label] === value;\n    });\n\n    if (result.length > 0) {\n        return result[0];\n    }\n\n    return {};\n};\n\n/**\n * Filter a JSON object (array) by value\n * @param jsonObject\n * @param value\n * @returns {{}|*}\n */\nvar filterByValue = exports.filterByValue = function filterByValue(jsonObject, value) {\n    if (typeof jsonObject === 'undefined') {\n        return {};\n    }\n\n    return jsonObject.filter(function (jsonObject) {\n        return jsonObject['value'] === value;\n    })[0];\n};\n\n/**\n *\n * @param array\n * @param element\n * @param key\n * @return {*}\n */\nvar upsert = exports.upsert = function upsert(array, element, key) {\n\n    var i = array.findIndex(function (_element) {\n        return _element[key] === element[key];\n    });\n\n    if (i > -1) {\n        array[i] = element;\n    } else {\n        array.push(element);\n    }\n\n    return array;\n};\n\n/**\n *\n * @param obj\n * @return {boolean}\n */\nvar isIterable = exports.isIterable = function isIterable(obj) {\n    // checks for null and undefined\n    if (obj == null) {\n        return false;\n    }\n\n    return typeof obj[Symbol.iterator] === 'function';\n};\n\n/**\n * Equivalent of PHP function array_unique\n *\n * @param arr\n * @return {unknown[]}\n */\nvar arrayUnique = exports.arrayUnique = function arrayUnique(arr) {\n    return [].concat(_toConsumableArray(new Set(arr)));\n};\n\n/**\n *\n * @param object\n * @return {string}\n */\nvar objectToEscapedJson = exports.objectToEscapedJson = function objectToEscapedJson(object) {\n    return JSON.stringify(object).replace(/\"/g, \"&quot;\");\n};\n\n/**\n *\n * @param json\n * @return {*}\n */\nvar escapedJsonToObject = exports.escapedJsonToObject = function escapedJsonToObject(json) {\n    return json.replaceAll(\"&quot;\", '\"');\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/utils/objects.js?")},3729:(__unused_webpack_module,exports,__webpack_require__)=>{eval('\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nexports.resolveField = undefined;\n\nvar _fields = __webpack_require__(857);\n\n/**\n *\n * @param fieldType\n * @return {{icon: string, label: string}}\n */\nvar resolveField = exports.resolveField = function resolveField(fieldType) {\n\n    var icon = \'bx:bx-map\';\n    var label = \'Address\';\n\n    switch (fieldType) {\n        case _fields.fieldTypes.BUTTON:\n            icon = "bx:bx-pointer";\n            label = "Button";\n            break;\n        case _fields.fieldTypes.CAPTCHA:\n            icon = "bx:bx-lock";\n            label = "Captcha";\n            break;\n        case _fields.fieldTypes.COLOR:\n            icon = "bx:bx-color-fill";\n            label = "Color";\n            break;\n        case _fields.fieldTypes.CURRENCY:\n            icon = "bx:bx-euro";\n            label = "Currency";\n            break;\n        case _fields.fieldTypes.WEIGHT:\n            icon = "bx:bx-tachometer";\n            label = "Weight";\n            break;\n        case _fields.fieldTypes.LENGTH:\n            icon = "bx:bx-ruler";\n            label = "Length";\n            break;\n        case _fields.fieldTypes.DATE:\n            icon = "bx:bx-calendar";\n            label = "Date";\n            break;\n        case _fields.fieldTypes.EDITOR:\n            icon = "bx:bx-font-color";\n            label = "Editor";\n            break;\n        case _fields.fieldTypes.EMAIL:\n            icon = "bx:bx-envelope";\n            label = "Email";\n            break;\n        case _fields.fieldTypes.HIDDEN:\n            icon = "ant-design:eye-invisible-outlined";\n            label = "Hidden";\n            break;\n        case _fields.fieldTypes.NUMBER:\n            icon = "bx:bx-hash";\n            label = "Number";\n            break;\n        case _fields.fieldTypes.PHONE:\n            icon = "bx:bx-phone";\n            label = "Phone";\n            break;\n        case _fields.fieldTypes.TEXT:\n            icon = "bx:bx-text";\n            label = "Text";\n            break;\n        case _fields.fieldTypes.TEXTAREA:\n            icon = "bx:bx-pen";\n            label = "Textarea";\n            break;\n        case _fields.fieldTypes.LIST:\n            icon = "bx:bx-list-ul";\n            label = "List";\n            break;\n        case _fields.fieldTypes.HTML:\n            icon = "bx:bx-code-alt";\n            label = "HTML";\n            break;\n        case _fields.fieldTypes.URL:\n            icon = "bx:bx-link";\n            label = "Url";\n            break;\n        case _fields.fieldTypes.SELECT:\n            icon = "bx:bx-select-multiple";\n            label = "Select";\n            break;\n        case _fields.fieldTypes.SELECT_MULTI:\n            icon = "bx:bxs-select-multiple";\n            label = "Select(multiple)";\n            break;\n        case _fields.fieldTypes.POST_OBJECT:\n            icon = "bx:pen";\n            label = "Post";\n            break;\n        case _fields.fieldTypes.POST_OBJECT_MULTI:\n            icon = "bxs:pen";\n            label = "Post(multiple)";\n            break;\n        case _fields.fieldTypes.TERM_OBJECT:\n            icon = "bx:purchase-tag-alt";\n            label = "Term";\n            break;\n        case _fields.fieldTypes.TERM_OBJECT_MULTI:\n            icon = "bxs:purchase-tag-alt";\n            label = "Term(multiple)";\n            break;\n        case _fields.fieldTypes.TOGGLE:\n            icon = "bx:bx-toggle-right";\n            label = "Toggle";\n            break;\n        case _fields.fieldTypes.EMBED:\n            icon = "bx:bx-extension";\n            label = "Embed";\n            break;\n        case _fields.fieldTypes.FILE:\n            icon = "bx:bx-cloud-upload";\n            label = "File";\n            break;\n        case _fields.fieldTypes.GALLERY:\n            icon = "bx:bx-images";\n            label = "Gallery";\n            break;\n        case _fields.fieldTypes.IMAGE:\n            icon = "bx:bx-image";\n            label = "Image";\n            break;\n        case _fields.fieldTypes.VIDEO:\n            icon = "bx:bx-video";\n            label = "Video";\n            break;\n        case _fields.fieldTypes.POST:\n            icon = "bx:bx-repost";\n            label = "Relationship";\n            break;\n        case _fields.fieldTypes.TIME:\n            icon = "bx:time-five";\n            label = "Time";\n            break;\n        case _fields.fieldTypes.REPEATER:\n            icon = "bx:folder-plus";\n            label = "Repeater";\n            break;\n        case _fields.fieldTypes.USER:\n            icon = "bx:user";\n            label = "User";\n            break;\n        case _fields.fieldTypes.USER_MULTI:\n            icon = "bx:user-plus";\n            label = "User(multiple)";\n            break;\n        case _fields.fieldTypes.CHECKBOX:\n            icon = "bx:checkbox-checked";\n            label = "Checkbox";\n            break;\n        case _fields.fieldTypes.RADIO:\n            icon = "bx:radio-circle-marked";\n            label = "Radio";\n            break;\n        case _fields.fieldTypes.DATE_RANGE:\n            icon = "bx:calendar-check";\n            label = "DateRange";\n            break;\n        case _fields.fieldTypes.DATE_TIME:\n            icon = "bxs:calendar-check";\n            label = "DateTime";\n            break;\n        case _fields.fieldTypes.FLEXIBLE:\n            icon = "bx:hive";\n            label = "Flexible";\n            break;\n        case _fields.fieldTypes.ICON:\n            icon = "bx:wink-smile";\n            label = "Icon";\n            break;\n        case _fields.fieldTypes.RANGE:\n            icon = "bx:slider-alt";\n            label = "Range";\n            break;\n        case _fields.fieldTypes.RATING:\n            icon = "bx:star";\n            label = "Rating";\n            break;\n        case _fields.fieldTypes.WORDPRESS_POST_TITLE:\n            icon = "bxl:wordpress";\n            label = "PostTitle";\n            break;\n        case _fields.fieldTypes.WORDPRESS_POST_CONTENT:\n            icon = "bxl:wordpress";\n            label = "PostContent";\n            break;\n        case _fields.fieldTypes.WORDPRESS_POST_EXCERPT:\n            icon = "bxl:wordpress";\n            label = "PostExcerpt";\n            break;\n        case _fields.fieldTypes.WORDPRESS_POST_DATE:\n            icon = "bxl:wordpress";\n            label = "PostDate";\n            break;\n        case _fields.fieldTypes.WORDPRESS_POST_AUTHOR:\n            icon = "bxl:wordpress";\n            label = "PostAuthor";\n            break;\n        case _fields.fieldTypes.WORDPRESS_USER_EMAIL:\n            icon = "bxl:wordpress";\n            label = "UserEmail";\n            break;\n        case _fields.fieldTypes.WORDPRESS_USER_FIRST_NAME:\n            icon = "bxl:wordpress";\n            label = "UserFirstName";\n            break;\n        case _fields.fieldTypes.WORDPRESS_USER_LAST_NAME:\n            icon = "bxl:wordpress";\n            label = "UserLastName";\n            break;\n        case _fields.fieldTypes.WORDPRESS_USER_USERNAME:\n            icon = "bxl:wordpress";\n            label = "Username";\n            break;\n        case _fields.fieldTypes.WORDPRESS_USER_PASSWORD:\n            icon = "bxl:wordpress";\n            label = "UserPassword";\n            break;\n        case _fields.fieldTypes.WORDPRESS_TERM_NAME:\n            icon = "bxl:wordpress";\n            label = "TermName";\n            break;\n        case _fields.fieldTypes.WORDPRESS_TERM_DESCRIPTION:\n            icon = "bxl:wordpress";\n            label = "TermDescription";\n            break;\n        case _fields.fieldTypes.WORDPRESS_TERM_SLUG:\n            icon = "bxl:wordpress";\n            label = "TermSlug";\n            break;\n    }\n\n    return { icon: icon, label: label };\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/utils/resolvers.js?')},8029:(__unused_webpack_module,exports)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Capitalize text\n *\n * @param txt\n * @return {string}\n */\nvar capitalizeTxt = exports.capitalizeTxt = function capitalizeTxt(txt) {\n    return txt.charAt(0).toUpperCase() + txt.slice(1); //or if you want lowercase the rest txt.slice(1).toLowerCase();\n};\n\n/**\n * Converts [0,0,20,0,'px'] into 0px 0px 20px 0px\n * @param values\n * @return {string|null}\n */\nvar squaresToString = exports.squaresToString = function squaresToString(values) {\n\n    if (values && typeof values !== 'undefined') {\n        return values[0] + values[4] + \" \" + values[1] + values[4] + \" \" + values[2] + values[4] + \" \" + values[3] + values[4];\n    }\n\n    return null;\n};\n\n/**\n *\n * @param item\n * @param searchTerm\n * @return {boolean}\n */\nvar likeThat = exports.likeThat = function likeThat(item, searchTerm) {\n    return item.toString().toLowerCase().indexOf(searchTerm.toString().toLowerCase()) > -1;\n};\n\n/**\n *\n * @param string\n * @return {*}\n */\nvar addSlashes = exports.addSlashes = function addSlashes(string) {\n    return string.replace(/\\\\/g, '\\\\\\\\').replace(/\\u0008/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/'/g, '\\\\\\'').replace(/\"/g, '\\\\\"');\n};\n\n/**\n *\n * @param string\n * @param maxLength\n * @return {string}\n */\nvar sluggifyString = exports.sluggifyString = function sluggifyString(string, maxLength) {\n\n    var sanitized = '';\n\n    if (typeof string === 'string') {\n        sanitized = string.toLowerCase();\n        sanitized = sanitized.replace(\" \", \"-\");\n        sanitized = sanitized.replace(/[^a-z0-9_\\-]/g, '-');\n    }\n\n    return sanitized.substr(0, maxLength ? maxLength : 20);\n};\n\n/**\n * Camelize a string\n *\n * @param str\n * @return {*}\n */\nvar camelize = exports.camelize = function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (word, index) {\n        return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    }).replace(/\\s+/g, '');\n};\n\n/**\n *\n * @param string\n * @param limit\n * @return {*}\n */\nvar substring = exports.substring = function substring(string) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n\n    return string.substring(0, limit);\n};\n\n/**\n *\n * @param uuid\n * @return {*|boolean}\n */\nvar isValidUuid = exports.isValidUuid = function isValidUuid(uuid) {\n    var regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\n    return typeof uuid === 'string' && regex.test(uuid);\n};\n\n/**\n *\n * @param str\n * @returns {boolean}\n */\nvar isNumeric = exports.isNumeric = function isNumeric(str) {\n\n    if (typeof str === 'number') {\n        return true;\n    }\n\n    if (typeof str === 'string') {\n        var parsedInt = parseInt(str);\n\n        return isNumeric(parsedInt);\n    }\n\n    return false;\n};\n\n/**\n *\n * @param str\n * @returns {*}\n */\nvar htmlspecialcharsDecode = exports.htmlspecialcharsDecode = function htmlspecialcharsDecode(str) {\n\n    var string = str.replace(/&#(\\d+);/g, function (match, dec) {\n        return String.fromCharCode(dec);\n    });\n\n    return string.replace(/&amp;/g, \"&\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&quot;/g, '\"').replace(/&#039;/g, \"'\");\n};\n\n/**\n *\n * @param length\n * @return {string}\n */\nvar randomAlphabeticString = exports.randomAlphabeticString = function randomAlphabeticString() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n\n    var result = '';\n    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n    var charactersLength = characters.length;\n\n    for (var i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n\n    return result;\n};\n\n/**\n *\n * @param regex\n * @param str\n * @return {boolean}\n */\nvar pregMatchAll = exports.pregMatchAll = function pregMatchAll(regex, str) {\n    return new RegExp(regex, 'g').matchAll(str);\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/App/utils/strings.js?")},5817:(__unused_webpack_module,exports,__webpack_require__)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _react = __webpack_require__(7294);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _fields = __webpack_require__(857);\n\nvar _react3 = __webpack_require__(4226);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ShortcodeIcon = function ShortcodeIcon(_ref) {\n    var type = _ref.type;\n\n\n    var resolveIconClass = function resolveIconClass(type) {\n        switch (type) {\n            case _fields.EMAIL:\n                return 'bx:bx-envelope';\n\n            case _fields.TEXT:\n                return 'bx:bx-text';\n\n            case _fields.SELECT:\n                return 'bx:bx-select-multiple';\n        }\n    };\n\n    return wp.element.createElement(_react3.Icon, { icon: resolveIconClass(type), width: \"18px\" });\n};\n\nexports.default = ShortcodeIcon;\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/components/ShortcodeBlock/ShortcodeIcon.js?")},7310:(__unused_webpack_module,exports,__webpack_require__)=>{eval('\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n\nvar _react = __webpack_require__(7294);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _metaFields = __webpack_require__(5814);\n\nvar _metaFields2 = _interopRequireDefault(_metaFields);\n\nvar _ShortcodeIcon = __webpack_require__(5817);\n\nvar _ShortcodeIcon2 = _interopRequireDefault(_ShortcodeIcon);\n\nvar _objects = __webpack_require__(4040);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ShortcodeBlock = function ShortcodeBlock(_ref) {\n    var props = _ref.props,\n        updateType = _ref.updateType;\n    var SelectControl = wp.components.SelectControl;\n\n\n    return wp.element.createElement(\n        "div",\n        { className: "acpt-block" },\n        wp.element.createElement(\n            "div",\n            { className: "controls" },\n            wp.element.createElement(SelectControl, {\n                label: "Select meta box field",\n                value: props.attributes.value,\n                options: _metaFields2.default,\n                onChange: function onChange(value) {\n                    return updateType(value);\n                }\n            })\n        ),\n        !(0, _objects.isEmpty)(props.attributes.content) && wp.element.createElement(\n            "p",\n            { className: "shortcode" },\n            props.attributes.type !== \'default\' && wp.element.createElement(\n                "span",\n                { className: "icon" },\n                wp.element.createElement(_ShortcodeIcon2.default, { type: props.attributes.type })\n            ),\n            props.attributes.content\n        )\n    );\n};\n\nexports.default = ShortcodeBlock;\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/components/ShortcodeBlock/index.js?')},5814:(__unused_webpack_module,exports,__webpack_require__)=>{eval('\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\n\nvar _metaTypes = __webpack_require__(1895);\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }\n\nvar fetchMeta = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var formData, response;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n                switch (_context.prev = _context.next) {\n                    case 0:\n                        formData = new FormData();\n\n                        formData.append(\'action\', \'fetchMetaAction\');\n                        formData.append(\'data\', JSON.stringify({ belongsTo: _metaTypes.metaTypes.CUSTOM_POST_TYPE, find: typenow }));\n\n                        _context.next = 5;\n                        return fetch(ajaxurl, {\n                            method: \'POST\',\n                            body: formData\n                        });\n\n                    case 5:\n                        response = _context.sent;\n                        _context.next = 8;\n                        return response.json();\n\n                    case 8:\n                        return _context.abrupt(\'return\', _context.sent);\n\n                    case 9:\n                    case \'end\':\n                        return _context.stop();\n                }\n            }\n        }, _callee, undefined);\n    }));\n\n    return function fetchMeta() {\n        return _ref.apply(this, arguments);\n    };\n}();\n\nvar metaFields = [{ value: null, label: "--Select---", box: "", field: "", type: "" }];\n\nfetchMeta().then(function (boxes) {\n    boxes.map(function (box) {\n        if (box.fields) {\n            box.fields.map(function (field) {\n                metaFields.push({\n                    value: field.db_name,\n                    label: field.ui_name,\n                    box: box.title,\n                    field: field.name,\n                    type: field.type\n                });\n            });\n        }\n    });\n});\n\nexports.default = metaFields;\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/data/metaFields.js?')},6058:(__unused_webpack_module,exports)=>{eval('\n\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nvar logoIcon = exports.logoIcon = wp.element.createElement(\'svg\', {\n    style: { fill: "#02c39a" },\n    viewBox: "0 0 634 572",\n    width: 24,\n    height: 24\n}, wp.element.createElement(\'path\', {\n    fillRule: "evenodd",\n    clipRule: "evenodd",\n    d: "M465.039 115.5L339.505 42.9755C333.314 39.3991 325.686 39.3991 319.495 42.9755L193.961 115.5L319.495 188.024C325.686 191.601 333.314 191.601 339.505 188.024L465.039 115.5ZM359.515 8.34015C340.943 -2.3891 318.057 -2.3891 299.485 8.34015L114 115.5L299.485 222.66C318.057 233.389 340.943 233.389 359.515 222.66L545 115.5L359.515 8.34015Z"\n}), wp.element.createElement(\'path\', {\n    fillRule: "evenodd",\n    clipRule: "evenodd",\n    d: "M520.34 209.498L394.765 281.952C388.572 285.524 384.758 292.131 384.76 299.28L384.801 444.258L510.376 371.805C516.568 368.232 520.383 361.625 520.381 354.476L520.34 209.498ZM374.775 247.305C356.197 258.024 344.754 277.844 344.76 299.292L344.82 513.507L530.366 406.452C548.944 395.733 560.387 375.913 560.381 354.465L560.32 140.25L374.775 247.305Z"\n}), wp.element.createElement(\'path\', {\n    opacity: "0.5",\n    fillRule: "evenodd",\n    clipRule: "evenodd",\n    d: "M275.34 444.259L275.381 299.281C275.383 292.131 271.568 285.525 265.376 281.952L139.801 209.498L139.76 354.476C139.758 361.625 143.572 368.232 149.765 371.805L275.34 444.259ZM315.381 299.292C315.387 277.844 303.944 258.024 285.366 247.305L99.8202 140.25L99.7599 354.465C99.7538 375.913 111.197 395.733 129.775 406.452L315.32 513.507L315.381 299.292Z"\n}));\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/icons/logoIcon.js?')},3578:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('\n\nvar _react = __webpack_require__(7294);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _isLodash = __webpack_require__(6659);\n\nvar _logoIcon = __webpack_require__(6058);\n\nvar _metaFields = __webpack_require__(5814);\n\nvar _metaFields2 = _interopRequireDefault(_metaFields);\n\nvar _ShortcodeBlock = __webpack_require__(7310);\n\nvar _ShortcodeBlock2 = _interopRequireDefault(_ShortcodeBlock);\n\n__webpack_require__(5984);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar registerBlockType = wp.blocks.registerBlockType;\n// scss\n\nif ((0, _isLodash.isLodash)()) {\n    _.noConflict();\n}\n\nregisterBlockType(\'advanced-custom-post-type/block\', {\n    title: \'Meta box fields\',\n    icon: _logoIcon.logoIcon,\n    category: \'advanced-custom-post-type-blocks\',\n    attributes: {\n        type: { type: \'string\', default: \'default\' },\n        title: { type: \'string\' },\n        content: { type: \'array\', source: \'children\', selector: \'p\' },\n        selectedOption: { type: \'object\' },\n        value: { type: \'string\' },\n        target: { type: \'string\' },\n        width: { type: \'string\' },\n        height: { type: \'string\' },\n        dateFormat: { type: \'string\' },\n        elements: { type: \'string\' }\n    },\n    edit: function edit(props) {\n\n        var updateType = function updateType(value) {\n            var option = _metaFields2.default.filter(function (y) {\n                return y.value === value;\n            })[0];\n            var content = value !== \'\' ? "[acpt box=\\"" + option.box + "\\" field=\\"" + option.field + "\\"]" : \'\';\n\n            props.setAttributes({ selectedOption: option });\n            props.setAttributes({ type: option.type });\n            props.setAttributes({ content: content });\n            props.setAttributes({ value: value });\n            props.setAttributes({ target: null });\n            props.setAttributes({ dateFormat: null });\n            props.setAttributes({ width: null });\n            props.setAttributes({ height: null });\n            props.setAttributes({ elements: null });\n        };\n\n        var updateHeight = function updateHeight(height) {\n            var content = "[acpt box=\\"" + props.attributes.selectedOption.box + "\\" field=\\"" + props.attributes.selectedOption.field + "\\" " + (props.attributes.width && props.attributes.width !== \'\' ? "width=\\"" + props.attributes.width + "\\"" : \'\') + " " + (height !== \'\' ? "height=\\"" + height + "\\"" : \'\') + "]";\n\n            props.setAttributes({ content: content });\n            props.setAttributes({ height: height });\n            props.setAttributes({ dateFormat: null });\n            props.setAttributes({ target: null });\n            props.setAttributes({ elements: null });\n        };\n\n        var updateWidth = function updateWidth(width) {\n            var content = "[acpt box=\\"" + props.attributes.selectedOption.box + "\\" field=\\"" + props.attributes.selectedOption.field + "\\" " + (width !== \'\' ? "width=\\"" + width + "\\"" : \'\') + " " + (props.attributes.height && props.attributes.height !== \'\' ? "height=\\"" + props.attributes.height + "\\"" : \'\') + "]";\n\n            props.setAttributes({ content: content });\n            props.setAttributes({ width: width });\n            props.setAttributes({ dateFormat: null });\n            props.setAttributes({ target: null });\n            props.setAttributes({ elements: null });\n        };\n\n        var updateTarget = function updateTarget(target) {\n            var content = "[acpt box=\\"" + props.attributes.selectedOption.box + "\\" field=\\"" + props.attributes.selectedOption.field + "\\" target=\\"" + target + "\\"]";\n\n            props.setAttributes({ content: content });\n            props.setAttributes({ target: target });\n            props.setAttributes({ dateFormat: null });\n            props.setAttributes({ width: null });\n            props.setAttributes({ height: null });\n            props.setAttributes({ elements: null });\n        };\n\n        var updateDateFormat = function updateDateFormat(dateFormat) {\n            var content = "[acpt box=\\"" + props.attributes.selectedOption.box + "\\" field=\\"" + props.attributes.selectedOption.field + "\\" date-format=\\"" + dateFormat + "\\"]";\n\n            props.setAttributes({ content: content });\n            props.setAttributes({ dateFormat: dateFormat });\n            props.setAttributes({ target: null });\n            props.setAttributes({ width: null });\n            props.setAttributes({ height: null });\n            props.setAttributes({ elements: null });\n        };\n\n        var updateElements = function updateElements(elements) {\n            var content = "[acpt box=\\"" + props.attributes.selectedOption.box + "\\" field=\\"" + props.attributes.selectedOption.field + "\\" elements=\\"" + elements + "\\"]";\n\n            props.setAttributes({ content: content });\n            props.setAttributes({ elements: elements });\n            props.setAttributes({ dateFormat: null });\n            props.setAttributes({ target: null });\n            props.setAttributes({ width: null });\n            props.setAttributes({ height: null });\n        };\n\n        return wp.element.createElement(_ShortcodeBlock2.default, {\n            props: props,\n            updateType: updateType,\n            updateWidth: updateWidth,\n            updateHeight: updateHeight,\n            updateTarget: updateTarget,\n            updateDateFormat: updateDateFormat,\n            updateElements: updateElements\n        });\n    },\n    save: function save(props) {\n\n        return wp.element.createElement(\n            "div",\n            { className: "acpt-block" },\n            wp.element.createElement(\n                "p",\n                { className: "shortcode" },\n                props.attributes.content\n            )\n        );\n    }\n});\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/index.js?')},6659:(__unused_webpack_module,exports)=>{eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Determines if _ is lodash or not\n */\nvar isLodash = exports.isLodash = function isLodash() {\n    var isLodash = false;\n\n    // If _ is defined and the function _.forEach exists then we know underscore OR lodash are in place\n    if ('undefined' != typeof _ && 'function' == typeof _.forEach) {\n\n        // A small sample of some of the functions that exist in lodash but not underscore\n        var funcs = ['get', 'set', 'at', 'cloneDeep'];\n\n        // Simplest if assume exists to start\n        isLodash = true;\n\n        funcs.forEach(function (func) {\n            // If just one of the functions do not exist, then not lodash\n            isLodash = 'function' != typeof _[func] ? false : isLodash;\n        });\n    }\n\n    if (isLodash) {\n        // We know that lodash is loaded in the _ variable\n        return true;\n    }\n\n    return false;\n};\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/tools/isLodash.js?")},5984:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./assets/src/Gutemberg/scss/block.scss?")},2408:(__unused_webpack_module,exports)=>{eval('/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version="18.2.0";\n\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./node_modules/react/cjs/react.production.min.js?')},7294:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n\nif (true) {\n  module.exports = __webpack_require__(2408);\n} else {}\n\n\n//# sourceURL=webpack://advanced-custom-post-type-lite/./node_modules/react/index.js?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(3578)})();